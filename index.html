<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Saber's Dice Vault</title>
    <style>
        body {
            margin: 0; padding: 0;
            background-color: #0a0a0a; color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
            background: radial-gradient(circle at center, #1a1a1a 0%, #050505 100%);
        }
        .dice-widget {
            width: 90vw; max-width: 380px; height: 550px;
            background: #151515; border-radius: 28px; border: 1px solid #333;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; overflow: hidden; position: relative;
        }
        #canvas-container { flex: 1; width: 100%; background: #000; position: relative; }
        .result-overlay { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 5; }
        .total-number {
            font-size: 4rem; font-weight: 900; color: #00ffcc;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
            opacity: 0; transform: scale(0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .total-number.show { opacity: 1; transform: scale(1); }
        .controls {
            background: #1a1a1a; padding: 16px;
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
            border-top: 1px solid #333; z-index: 10;
        }
        .dice-btn {
            background: #252525; border: 1px solid #333; color: #aaa;
            padding: 10px 4px; border-radius: 12px; font-size: 0.75rem; font-weight: 700;
            cursor: pointer; display: flex; flex-direction: column; align-items: center;
        }
        .dice-btn:active { transform: scale(0.95); }
        .roll-btn {
            grid-column: span 3; background: #00ffcc; color: #000; border: none;
            padding: 14px; border-radius: 12px; font-weight: 900; font-size: 1rem;
            margin-top: 4px; cursor: pointer; text-transform: uppercase;
        }
        .clear-btn {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255,255,255,0.1); border: none; color: #888;
            font-size: 0.6rem; padding: 5px 10px; border-radius: 20px; cursor: pointer; z-index: 6;
        }
    </style>
</head>
<body>
    <div class="dice-widget">
        <div class="result-overlay"><div id="result-total" class="total-number">0</div></div>
        <div id="canvas-container"><button class="clear-btn" onclick="clearDice()">RESET</button></div>
        <div class="controls">
            <button class="dice-btn" onclick="addDice('d4')">D4</button>
            <button class="dice-btn" onclick="addDice('d6')">D6</button>
            <button class="dice-btn" onclick="addDice('d8')">D8</button>
            <button class="dice-btn" onclick="addDice('d10')">D10</button>
            <button class="dice-btn" onclick="addDice('d12')">D12</button>
            <button class="dice-btn" onclick="addDice('d20')">D20</button>
            <button class="roll-btn" onclick="rollAll()">Roll Dice</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        camera.position.set(0, 10, 0);
        camera.lookAt(0, 0, 0);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(5, 10, 2);
        light.castShadow = true;
        scene.add(light);

        const world = new CANNON.World();
        world.gravity.set(0, -25, 0);
        world.allowSleep = true;

        const diceMaterial = new CANNON.Material();
        const floorMaterial = new CANNON.Material();
        const contactMaterial = new CANNON.ContactMaterial(floorMaterial, diceMaterial, { friction: 0.3, restitution: 0.1 });
        world.addContactMaterial(contactMaterial);

        const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: floorMaterial });
        floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(floorBody);

        function createWall(x, y, z, rotX, rotY) {
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: floorMaterial });
            body.position.set(x, y, z);
            if (rotX) body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), rotX);
            if (rotY) body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotY);
            world.addBody(body);
        }
        createWall(3.2, 0, 0, 0, -Math.PI/2); createWall(-3.2, 0, 0, 0, Math.PI/2);
        createWall(0, 0, 4.5, 0, Math.PI); createWall(0, 0, -4.5, 0, 0);

        const diceList = [];
        const colors = [0x00ffcc, 0xff0066, 0x7000ff, 0xffcc00];

        function createDiceTexture(number, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px Inter, Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(number, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshPhongMaterial({ map: texture, flatShading: true });
        }

        function getDiceParams(type) {
            switch(type) {
                case 'd4': return { geom: new THREE.TetrahedronGeometry(1.1), sides: 4 };
                case 'd6': return { geom: new THREE.BoxGeometry(1.2, 1.2, 1.2), sides: 6 };
                case 'd8': return { geom: new THREE.OctahedronGeometry(1.1), sides: 8 };
                case 'd10': return { geom: new THREE.IcosahedronGeometry(1.1, 0), sides: 10 }; 
                case 'd12': return { geom: new THREE.DodecahedronGeometry(1.1), sides: 12 };
                case 'd20': return { geom: new THREE.IcosahedronGeometry(1.2), sides: 20 };
            }
        }

        function addDice(type) {
            if (diceList.length >= 8) return;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const params = getDiceParams(type);
            const geometry = params.geom;
            
            // To ensure every face has a texture, we map a material to every face index
            const materials = [];
            const faceCount = geometry.attributes.position.count / 3;
            for (let i = 0; i < faceCount; i++) {
                // Simplified: give each face a number from 1 to 'sides'
                materials.push(createDiceTexture((i % params.sides) + 1, color));
            }
            
            // Re-map group indices so Three.js knows which triangle uses which material
            geometry.clearGroups();
            for (let i = 0; i < faceCount; i++) {
                geometry.addGroup(i * 3, 3, i);
            }

            const mesh = new THREE.Mesh(geometry, materials);
            mesh.castShadow = true;
            scene.add(mesh);

            let shape;
            if (type === 'd6') shape = new CANNON.Box(new CANNON.Vec3(0.6, 0.6, 0.6));
            else shape = new CANNON.Sphere(0.8);

            const body = new CANNON.Body({ mass: 1, shape: shape, material: diceMaterial });
            body.position.set(Math.random()-0.5, 4, Math.random()-0.5);
            body.linearDamping = 0.4; body.angularDamping = 0.4;
            world.addBody(body);
            diceList.push({ mesh, body, type, sides: params.sides });
        }

        function getUpwardFace(mesh) {
            const vector = new THREE.Vector3(0, 1, 0); // World Up
            let maxDot = -1;
            let bestFaceIndex = 0;

            const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
            const position = mesh.geometry.attributes.position;

            // Check each face normal
            for (let i = 0; i < position.count; i += 3) {
                const vA = new THREE.Vector3().fromBufferAttribute(position, i);
                const vB = new THREE.Vector3().fromBufferAttribute(position, i+1);
                const vC = new THREE.Vector3().fromBufferAttribute(position, i+2);
                
                const cb = new THREE.Vector3().subVectors(vC, vB);
                const ab = new THREE.Vector3().subVectors(vA, vB);
                const normal = cb.cross(ab).normalize().applyMatrix3(normalMatrix);

                const dot = normal.dot(vector);
                if (dot > maxDot) {
                    maxDot = dot;
                    bestFaceIndex = i / 3;
                }
            }
            // Return the number assigned to that face material
            return (bestFaceIndex % mesh.userData.sides) + 1;
        }

        function rollAll() {
            if (diceList.length === 0) return;
            document.getElementById('result-total').classList.remove('show');
            diceList.forEach(dice => {
                dice.mesh.userData.sides = dice.sides; // Store for face detection
                dice.body.wakeUp();
                dice.body.position.set(Math.random()-0.5, 5, Math.random()-0.5);
                dice.body.velocity.set((Math.random()-0.5)*15, -12, (Math.random()-0.5)*15);
                dice.body.angularVelocity.set(Math.random()*25, Math.random()*25, Math.random()*25);
            });

            setTimeout(() => {
                let total = 0;
                diceList.forEach(dice => {
                    total += getUpwardFace(dice.mesh);
                });
                const el = document.getElementById('result-total');
                el.innerText = total;
                el.classList.add('show');
            }, 1500);
        }

        function clearDice() {
            diceList.forEach(d => { scene.remove(d.mesh); world.remove(d.body); });
            diceList.length = 0;
            document.getElementById('result-total').classList.remove('show');
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(1/60);
            diceList.forEach(d => {
                d.mesh.position.copy(d.body.position);
                d.mesh.quaternion.copy(d.body.quaternion);
            });
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
